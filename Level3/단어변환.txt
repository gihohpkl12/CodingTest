import java.util.ArrayList;

/*
간단한 DFS 문제.
물론 BFS로도 가능함.
*/
class Solution {
    static int answer = 0;
    public int solution(String begin, String target, String[] words) {
        answer = Integer.MAX_VALUE;
        
        // DFS를 위한 리스트 생성
        ArrayList<String> wordList = new ArrayList<>();
        for(String word : words) {
            wordList.add(word);
        }
        
        searchForWordChange(target, begin, wordList, 0);
        return answer == Integer.MAX_VALUE ? 0 : answer;
    }
    
    // DFS
    public void searchForWordChange(String target, String curWord, ArrayList<String> words, int count) {
        // 목표거나 더이상 체크할 경우가 없으면 return
        if(curWord.equals(target)) {
            answer = count != 0 && answer > count ? count : answer;
            return;
        } else if(words.size() == 0) {
            return;
        }
        
        // 변환할 리스트 확인
        for(int i = 0; i < words.size(); i++) {
            String getWord = words.get(i);
            
            if(wordChangeCheck(curWord, getWord)) {
                words.remove(i);
                searchForWordChange(target, getWord, words, count+1);
                words.add(i, getWord);    
            }
        }
    }
    
    // 단어 변환 가능 여부 체크
    public boolean wordChangeCheck(String pre, String next) {
        int count = 0;
        for(int i = 0; i < next.length(); i++) {
            count += pre.charAt(i) != next.charAt(i) ? 1 : 0;
            if(count > 1) {
                return false;
            }
        }
        return true;
    }
}


----------------------------------------------------------------------------------------------------------------------------------------------------------------

import java.util.LinkedList;
import java.util.Queue;
import java.util.HashMap;
import java.util.Comparator;
import java.util.Arrays;

class Solution {
	 public int solution(String begin, String target, String[] words) {
	        int answer = -1;
	        for(int i =0; i<words.length; i++)
	        {
	        	if(words[i].equals(target))
	        	{
	        		answer = 0;
	        		break;
	        	}
	        }
	        if(answer !=0)
	        	return 0;
	        Arrays.sort(words, new Comparator<String>() 
	        {
	        	public int compare(String o1, String o2)
	        	{
	        		if(o1.equals(target))
	        			return 1;
	        		if(o2.equals(target))
	        			return -1;
	        		else
	        			return 0;
	        	}
	        });
	        answer = bfs(begin, target, words); 
	        return answer;
	    }
	 
	 public boolean wordcheck(String begin, String target)
	 {
		 boolean result = true;
		 int count = 0;
		 HashMap<Integer, Integer> map = new HashMap<>();
		 
		 for(int i =0; i<begin.length(); i++)
		 {
			 String temp = begin.substring(i,i+1);
			 int index =0;
			 while(index!=-1)
			 {
				 index = target.indexOf(temp,index);
				 if(index==-1)
				 {
					 count++;
					 break;
				 }
				 if(!map.containsKey(index))
				 {
					 map.put(index, index);
					 break;
				 }else
				 {
					 index+=1;
				 }
			 }
			 if(count>=2)
			 {
				 result = false;
				 break;
			 }
		 }
		 return result;
	 }
    public int bfs(String begin, String target, String[] words)
	 {
		 Queue<word> Q = new LinkedList<>();
		 Q.add(new word(0,begin));
		 int answer = Integer.MAX_VALUE;
		 for(int i =0; i<words.length; i++)
		 {
			 int Qcount = Q.size();
			 while(Qcount>0)
			 {
				 word temp = Q.poll();
				 if(words[i].equals(target))
				 {
					 if(wordcheck(temp.word,words[i]))
						answer = temp.count+1<answer ? temp.count+1 : answer; 
					 Qcount--;
					 continue;
				 }
				 if(wordcheck(temp.word, words[i]))
				 {
					 Q.add(temp);
					 word temp2 = new word(temp.count+1, words[i]);
					 Q.add(temp2);
					 
				 }else
					 Q.add(temp);
				 Qcount--;
			 }
		 }
		 return answer;
	 }
	 class word
	 {
		 int count;
		 String word;
		 public word(int count, String word)
		 {
			 this.count  = count;
			 this.word = word;
		 }
	 }
}

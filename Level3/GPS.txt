/*
문제 풀이
DP로 접근하지 않으면 시간 초과.
HashMap 안에 HashMap을 넣는 것보다, Hash[]로 만드는 것이 메모리적으로 더 효율적.
로직.
처음 시작하는 곳은 0으로 초기화함. (문제 규칙에 시작지점과 끝지점은 항상 옳다고 명시)
다음 구간부터 DP의 개념으로 
이동할 경우와 이동하지 않을 경우를 계산함.
현재의 값은 이전의 값 + 이동할 경우 증가할 값이 됨. (같은 노드 -> 같은 노드 라면 0, 아니라면 1)

정답은 
맨 마지막 전에 계산한 값 중에 최소가 됨.(맨 마지막은 계산하지 않아도 됨. 무조건 옳기 때문에 0임)
*/
import java.util.ArrayList;  
import java.util.Arrays;

class Solution {
	public int solution(int n, int m, int[][] edge_list, int k, int[] gps_log) {
		int answer = 987654321;
		int[][] dp = new int[n+1][n+1];
		ArrayList<Integer>[] map = new ArrayList[n+1];

		for(int[] a : dp) {
			Arrays.fill(a, 987654321);
		}
		
		for(int i = 0; i< map.length; i++)
			map[i] = new ArrayList<>();

		for(int i = 0; i< edge_list.length; i++) {
			int start = edge_list[i][0], end = edge_list[i][1];
			map[start].add(end);
			map[end].add(start);
		}
		
		dp[0][gps_log[0]] = 0;
		for(int i = 1; i< gps_log.length-1; i++) {
			for(int j = 1; j<=n; j++) {
				int add = gps_log[i]==j ? 0 : 1;
				dp[i][j] = Math.min( dp[i-1][j]+add, dp[i][j]);
				for(int q : map[j]) {
					dp[i][j] = Math.min(dp[i][j], dp[i-1][q]+add);
				}
			}
		}
		for(int p : map[gps_log[k-1]]) {
		    answer = Math.min(answer, dp[gps_log.length-2][p]);
		}

		return answer!=987654321 ? answer : -1;
	}
}

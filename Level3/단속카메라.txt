import java.util.Arrays;
import java.util.Comparator;
import java.util.ArrayList;

/*
아이디어가 중요한 문제.
그리디한 문제임.
차량을 먼저 나간 순서대로 정렬함.
그리고 우선 맨 처음 나간 차량을 저장함(나가는 지점).
해당 지점을 기준으로 해당 지점보다 이전에 들어와서 해당 지점보다 늦게 혹은 같게 나가면 체크됨.
해당 기준에 딱 들어와도 체크됨.
이 두가지 기준만 체크하면 됨.
*/

class Solution {
    public int solution(int[][] routes) {
        ArrayList<Integer> cameras = new ArrayList<>();
        sort(routes);
        setCamera(cameras, routes);
        
        return cameras.size();
    }
    
    public void setCamera(ArrayList<Integer> cameras, int[][] routes) {
        cameras.add(routes[0][1]);
        
        // 전체 차량들 점검
        for(int i = 1; i < routes.length; i++) {
            boolean saveCheck = false;
            
            // 설치된 카메라로 해당 인덱스(i)번재 차량이 체크가 되는지 확인함.
            for(int cameraIndex = 0; cameraIndex < cameras.size(); cameraIndex++) {
                int end = cameras.get(cameraIndex);
                
                if(routes[i][1] >= end && routes[i][0] <= end) {
                    saveCheck = false;
                    break;
                } else if(routes[i][0] == end) {
                    saveCheck = false;
                    break;
                } else {
                    saveCheck = true;
                }
            }
            // 다 검사해서 결국 체크를 못 했으면 카메라로 저장함.
            if(saveCheck) {
                cameras.add(routes[i][1]);
            }
        }
    }
    // 카메라 정렬(나간 순서대로)
    public void sort(int[][] routes) {
        Arrays.sort(routes, new Comparator<int[]>(){
            public int compare(int[] o1, int[] o2) {
                return o1[1] - o2[1];
            }
        });
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
class Solution {
      public int solution(int[][] routes) {
	        ArrayList<int[]> camera = new ArrayList<>();
	        Arrays.sort(routes, new Comparator<int[]>() 
	        {
	        	public int compare(int[] o1, int[] o2)
	        	{
	        		if(o1[1]>o2[1])
	        			return 1;
	        		if(o1[1]<o2[1])
	        			return -1;
	        		return 0;
	        					
	        	}
	        });
	        for(int i =0; i< routes.length; i++)
	        {
	        	if(camera.size()==0)
	        		camera.add(routes[i]);
	        	else
	        	{
	        		boolean saveCheck = true;
	        		for(int j =0; j< camera.size(); j++)
	        		{
	        			int[] temp = camera.get(j);
	        			if(!overlapcheck(routes[i][0],routes[i][1],temp))
	        				continue;
	        			else
	        			{
	        				saveCheck = false;
	        				temp = setRange(routes[i][0], routes[i][1], temp);
	        				camera.set(j, temp);
	        				break;
	        			}
	        		}
	        		if(saveCheck)
	        			camera.add(routes[i]);
	        	}
	        }
        
	        return camera.size();
	    }
	 public boolean overlapcheck(int start, int end, int[] arr)
	 {
		 boolean result = false;
		 if(arr[1]>=start && arr[1]<=end)
			 result = true;
		 else if(arr[0]>=start && arr[0]<=end)
			 result = true;
		 else if(start>=arr[0] && end<=arr[1])
			 result = true;
		 return result;
	 }
	 public int[] setRange(int start, int end, int[] arr)
	 {
		 int[] result = new int[2];
		 if(start==arr[0])
		 	 result[0] = start;
		 else
		 	 result[0] =  start>arr[0] ? start : arr[0];
		 if(end == arr[1])
			 result[1] = end;
		 else
			 result[1] = end<arr[1] ? end : arr[1]; 
		 return result;
	 }
}

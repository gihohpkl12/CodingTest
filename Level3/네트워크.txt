import java.util.HashSet;

/*
DFS나 BFS로 풀 수 있는 문제지만, 동시에 유니온 파인드로도 풀 수 있음.
케이스 9번이 이상함
*/
class Solution {
    public int solution(int n, int[][] computers) {        
        int[] nodes = new int[n];
        for(int i = 0; i < nodes.length; i++) {
            nodes[i] = i;
        }
        
        for(int i = 0; i < computers.length; i++) {
            for(int j = 0; j < computers[i].length; j++) {
                if(j == i) {
                    continue;
                }
                
                if(computers[i][j] != 0 && nodes[i] != nodes[j]) {
                    union(i, j, nodes);
                }
            }
        }
        
        // 그냥 nodes 배열로 하면 9번이 틀림.
        HashSet<Integer> group = new HashSet<>();
        for(int i : nodes) {
            group.add(findGroup(nodes, i));
        }
        
        return group.size();
    }
    public void union(int i, int j, int[] nodes) {
        int groupA = findGroup(nodes, i);
        int groupB = findGroup(nodes, j);

        if(groupA < groupB) {
            nodes[groupB] = groupA;
        } else {
            nodes[groupA] = groupB;
        }
    }
    
    public int findGroup(int[] nodes, int nodeNum) {
        if(nodes[nodeNum] == nodeNum) {
            return nodeNum;   
        }
        return nodes[nodeNum] = findGroup(nodes, nodes[nodeNum]);
    }
}
/*

int[] test = {0,1,2,3,4,5,6,7,8,9};
        int a = findGroup(test, 0);
        int b = findGroup(test, 1);
        union(a, b, test);
        
        for(int i : test) {
            System.out.print(i+" ");
        }
        System.out.println();
        
        a = findGroup(test, 0);
        b = findGroup(test, 2);
        union(a, b, test);
        
        for(int i : test) {
            System.out.print(i+" ");
        }
        System.out.println();
        
         a = findGroup(test, 0);
        b = findGroup(test, 9);
        union(a, b, test);
        
        for(int i : test) {
            System.out.print(i+" ");
        }
        System.out.println();
        
         a = findGroup(test, 4);
        b = findGroup(test, 5);
        union(a, b, test);
        
        for(int i : test) {
            System.out.print(i+" ");
        }
        System.out.println();
        
         a = findGroup(test, 4);
        b = findGroup(test, 9);
        union(a, b, test);
        
        for(int i : test) {
            System.out.print(i+" ");
        }
        System.out.println();
        



*/

-----------------------------------------------------------------------------------------------------------------------------------------
import java.util.LinkedHashMap;
import java.util.ArrayList;
class Solution {
   public int solution(int n, int[][] computers) {
	        int answer = n;
	        boolean[] check = new boolean[n];
	        LinkedHashMap<Integer,ArrayList<Integer>> map = new LinkedHashMap<>();
	        for(int i=0; i<computers.length; i++)
	        {
	        	ArrayList<Integer> temp = new ArrayList<>();
	        	for(int j =0; j<computers[0].length; j++)
	        	{
	        		if(i==j || check[j]) continue;
	        		if(computers[i][j] == 1)
	        			temp.add(j);
	        	}
	        	if(temp.size()!=0)
	        	{
	        		for(int j =0; j<temp.size(); j++)
	        		{
	        			if(check[temp.get(j)]) continue;
	        			if(map.containsKey(i))
	        			{
	        				ArrayList<Integer> map_temp = map.get(i);
	        				map_temp.add(temp.get(j));
	        				map.replace(i, map_temp);
	        			}
	        			else
	        			{
	        				ArrayList<Integer> map_temp = new ArrayList<>();
	        				map_temp.add(temp.get(j));
	        				map.put(i,map_temp);
	        			}
	        			check[temp.get(j)] = true;
	        			research(computers, map,i,check, temp.get(j));
	        		}
	        	}
	        	check[i] = true;
	        	
	        }
	        for(int i : map.keySet())
	        	answer -= map.get(i).size();
	        return answer;
	    }
	 public void research(int[][] computers, LinkedHashMap<Integer,ArrayList<Integer>> map, int key, boolean[] check,int j)
	 {
		 
		 ArrayList<Integer> next = new ArrayList<>();
		 for(int i =0; i<computers.length; i++)
		 {
			 if(i == key || check[i] || i==j) continue;
			 if(computers[j][i]==1) 
			 {
				 next.add(i);
				 check[i] = true;
			 }
		 }
		 if(next.size()!=0)
		 {
			 for(int i =0; i<next.size(); i++ )
			 {
				 ArrayList<Integer> map_temp = map.get(key);
				 map_temp.add(next.get(i));
				 map.replace(key, map_temp);
				 check[next.get(i)] = true;
				 research(computers, map,key,check,next.get(i));
			 }
		 }
		 return;
	 }
}

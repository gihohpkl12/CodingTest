import java.util.Arrays;
/*
규칙만 파악하면 단순한 문제.
우선 나머지가 0일 때 값일 때가 곱할 때 가장 큼.
나머지가 0이 될 때까지 값을 처리하면 됨.

우선 n으로 s를 나눔.
여기서 분기하게 됨.
나머지가 0 vs 0아님

0이면 그냥 그 값으로 남은 배열을 채우면 됨.
아니면 n을 -1하고, s에 s/n을 빼주면 됨.

이렇게 풀면 정렬이 따로 필요가 없음.
왜?
가장 큰 값(n)으로 s를 나누기 때문에 자연스럽게 맨 처음 값이 가장 적게 됨.
뒤로 진행할수록 n은 계속 줄어들고, s는 가장 큰 값으로 나눈 가장 작은 값을 빼므로.

아래 풀이랑 이 풀이중에 뭐가 더 좋은지는 모르겠음.
*/

class Solution {
    public int[] solution(int n, int s) {
        int[] answer;
        if(s/n == 0) {
            // 이 경우에는 값을 채울 수 없음. -1임
            return new int[] {-1};
        }
        
        int index = 0;
        answer = new int[n];
        while(n > 0) {
            // 0이 아니면 n-1, s값 조정 후 다시.
            if(n%s != 0) {
                divideAndSetValue(answer, index, n, s);
                s -= s/n;
                n--;
            } else {
                // 0인 경우에는 끝.
                setAllSameNum(answer, index, s/n);
                break;
            }
            index++;
        } 
        
        // Arrays.sort(answer); 필요없음.
        return answer;
    }
    
    public void divideAndSetValue(int[] answer, int index, int n, int s) {
        answer[index] = s/n;
    }
    
    public void setAllSameNum(int[] answer, int index, int sameNum) {
        for(int i = index; i < answer.length; i++) {
            answer[i] = sameNum;
        }
    }
}

------------------------------------------------------------------------------------

class Solution {
    public int[] solution(int n, int s) {
	        int[] answer = new int[n];
	        int average = s/n, rest = s%n;
	        if(s<n)
	        	return new int[] {-1};
	        for(int i =0; i< answer.length; i++)
	        	answer[i] = average;
	        int index = answer.length-1;
	        for(int i = 0; i<rest; i++)
	        {
	        	answer[index]+=1;
	        	index--;
	        }
	        return answer;
	    }
}

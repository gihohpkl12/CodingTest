import java.util.PriorityQueue;
import java.util.Collections;

/*
간단한 문제임.
제곱할 때, 값을 줄이기 위해서 가장 큰수를 줄이면 됨.
PriorityQueue에 reverseOrder로 넣어서
가장 큰 값을 1씩 n번 줄이면 됨.
*/
class Solution {
    public long solution(int n, int[] works) {
        long answer = 0;
        PriorityQueue<Long> workTimes = new PriorityQueue<>(Collections.reverseOrder());
        setWorkTime(workTimes, works);
        decountTime(workTimes, n);
        
        return calTimes(workTimes);
    }
    public void setWorkTime(PriorityQueue<Long> workTimes, int[] works) {
        for(int work : works) {
            workTimes.add((long)work);
        }
    }
    
    public void decountTime(PriorityQueue<Long> workTimes, int n) {
        while(n > 0) {
            long time = workTimes.poll();
            if(time == 0) {
                break;
            }
            time--;
            n--;
            workTimes.add(time);
        }
    }
    
    public long calTimes(PriorityQueue<Long> workTimes) {
        long result = 0;
        while(workTimes.size() != 0) {
            long time = workTimes.poll();
            result += (time*time);
        }
        return result;
    }
}


--------------------------------------------------------------------------------------------------------------------------------------------------------

import java.util.PriorityQueue;
import java.util.Collections;
class Solution {
    public long solution(int n, int[] works) {
        long answer = 0;
        PriorityQueue<Integer> Q = new PriorityQueue<Integer>(Collections.reverseOrder());
        for(int i : works)
        	Q.add(i);
        while(Q.size()!=0 && n>0)
        {
        	int work = Q.poll();
        	if(work>0)
        	{
        		Q.add(work-1);
        		n--;
        	}
        }
        if(Q.size()==0)
        	return 0;
        while(Q.size()!=0)
        {
        	int work = Q.poll();
        	answer += work*work;
        }
        return answer;
    }
}
